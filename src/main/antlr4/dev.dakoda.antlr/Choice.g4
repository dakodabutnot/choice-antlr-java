grammar Choice;
choice: root;

WS: [ \t\r] -> skip;
TRUE: T R U E;
FALSE: F A L S E;
BOOLEAN_OPERATOR: GREATER_THAN | GREATER_THAN_EQUAL | LESS_THAN | LESS_THAN_EQUAL | EQUAL | NOT_EQUAL;
THEN: '-' T H E N '->';
IF_PREFIX: '-' I F '(';
SWITCH_PREFIX: '-' S W I T C H '(';
SELECTOR_SUFFIX: ')->';
ELSE: '-' E L S E '->';
ROOT_START: ROOT;
BRANCH_START: BRANCH;
VAR_START: VAR;
NEST_START: '{';
NEST_END: '};';
TEXT_CHARACTER_RESTRICTED: CHAR | ANY_NUMBER;
TEXT_CHARACTER: (CHAR | ANY_NUMBER | [-]|[ ]|[?!()]);
STRING: QUOTE TEXT_CHARACTER+ QUOTE;
CHAR: [A-z];
ANY_CHAR: A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z;
ANY_NUMBER: [0-9];
POSITIVE_NUMBER: [1-9];
INTEGER: POSITIVE_NUMBER (ANY_NUMBER*);
FLOAT: ([0] | POSITIVE_NUMBER ANY_NUMBER*) ('.' ANY_NUMBER* POSITIVE_NUMBER*)?;
WHITESPACE: (' '|'\t');
NEWLINE: ('\r'?'\n'|'\r');
STATEMENT_END: ';';
EMPTY_STRING: QUOTE QUOTE;
METHOD: '#' TEXT_CHARACTER_RESTRICTED+;

float: FLOAT;
integer: INTEGER;
number: integer | float;
boolean: TRUE | FALSE;
branchName: STRING;
switchCase: STRING;
branchDisplay: STRING;
string: STRING;
arrayOfValues: '[' arrayContents ']';
arrayContents: (simpleVariable (',' simpleVariable)*);
simpleVariable: (boolean | string | number);
variable: (simpleVariable | arrayOfValues);
method: METHOD;
methods: method (',' method)*?;
booleanExpression: boolean | simpleBooleanExpression | reversedBoolean;
simpleBooleanExpression: (number | method) BOOLEAN_OPERATOR (number | method);
reversedBoolean: '!('  simpleBooleanExpression ')';

content: (NEWLINE | branch | branchVar | selector)*;
elseContent: (NEWLINE | branch | branchVar | selector)*;
rootStart: ROOT_START variable? NEST_START NEWLINE;
nestEnd: NEST_END;
root: rootStart content nestEnd;

branchVariableOrMethod: (variable | methods | variable THEN methods);
branch: simpleBranch | blankBranch | nestingBranch | ifBranchTernary;
blankBranch: BRANCH_START branchName (',' branchDisplay)? '~' STATEMENT_END? NEWLINE;
simpleBranch: BRANCH_START branchName (',' branchDisplay)? '~' branchVariableOrMethod? STATEMENT_END NEWLINE;
nestingBranch: BRANCH_START branchName (',' branchDisplay)? '~' branchVariableOrMethod? NEST_START NEWLINE content nestEnd;
switchBranch: switchBranchNormal | switchBlankBranch;
switchBranchNormal: switchCase branch;
switchBlankBranch: switchCase BRANCH_START '~';
ifBranchTernary: BRANCH_START booleanExpression branch;

branchVar: branchSimpleVar | branchNestingVar;
branchSimpleVar: VAR_START variable STATEMENT_END NEWLINE;
branchNestingVar: VAR_START NEST_START NEWLINE branchNestingVarContent nestEnd;
branchNestingVarContent: keyValuePair*;
key: STRING;
value: (simpleVariable | arrayOfValues);
keyValuePair: key ':' value ',' NEWLINE;

selector: if | switch;
switch: '-switch(' (number | string | method) ')->' NEST_START switchContent nestEnd;
switchContent: (NEWLINE | switchBranch)*;
if: normalIf | ifElse;
normalIf: '-if(' booleanExpression ')->' NEST_START content nestEnd;
ifElse: '-if(' booleanExpression ')->' NEST_START content '}' ELSE NEST_START elseContent nestEnd;


fragment A: 'a';
fragment B: 'b';
fragment C: 'c';
fragment D: 'd';
fragment E: 'e';
fragment F: 'f';
fragment G: 'g';
fragment H: 'h';
fragment I: 'i';
fragment J: 'j';
fragment K: 'k';
fragment L: 'l';
fragment M: 'm';
fragment N: 'n';
fragment O: 'o';
fragment P: 'p';
fragment Q: 'q';
fragment R: 'r';
fragment S: 's';
fragment T: 't';
fragment U: 'u';
fragment V: 'v';
fragment W: 'w';
fragment X: 'x';
fragment Y: 'y';
fragment Z: 'z';
fragment GREATER_THAN: '>';
fragment LESS_THAN: '<';
fragment GREATER_THAN_EQUAL: GREATER_THAN '=';
fragment LESS_THAN_EQUAL: LESS_THAN '=';
fragment EQUAL: '==';
fragment NOT_EQUAL: NOT '=';
fragment NOT: '!';
fragment COMMA: ',';
fragment QUOTE: '"';
fragment ROOT: '=>';
fragment VAR: '~>';
fragment BRANCH: '->';